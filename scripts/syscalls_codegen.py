#!/usr/bin/env python3
"""
Parses solana syscalls and creates java code that will assign the corresponding
function signatures in the eBPFSolanaAnalyzer
"""
import re
FUNCTION_RE = re.compile(r'(?P<return_type>[\w_\*\[\]\d]*)\s+?(?P<name>[\*\w\d_]*)\((?P<args>(.*))\)')

class FunctionEntry:

    def __init__(self, code: str, description: str, line_num: int):
        self.raw_code: str = code
        self.description = description
        self.line_num = line_num

        self.name: str = ''
        self.return_type: str = ''
        self.args: list[tuple(str, str)] = []
    
    def parse(self):
        m = FUNCTION_RE.search(self.raw_code)
        if not m:
            raise Exception(f"Could not parse code at line {self.line_num}: {self.raw_code}")
        
        self.return_type = m.group('return_type')
        self.name = m.group('name')

        # in case the format "char *data" was used, move any asterisks to the type
        while self.name.startswith('*'):
            self.return_type += '*'
            self.name = self.name[1:]

        args_str = m.group('args')
        # no args
        if not args_str:
            return
        
        # parse the arguments
        # expects that there is a single whitespace between the type and the name
        for arg in args_str.split(','):
            try:
                arg_type, arg_name = arg.strip().split(' ')
            except ValueError:
                raise Exception(f"Unexpected whitespace in arguments string {arg}")

            # in case the format "char *data" was used, move any asterisks to the type
            while arg_name.startswith('*'):
                arg_type += '*'
                arg_name = arg_name[1:]
            self.args.append((arg_type, arg_name))

    def generate_java_code(self) -> str:
        s = f'''
        case("{self.name}"):
            model.setSignatureFieldText("{self.raw_code}");
            try {{
                model.parseSignatureFieldText();
            }} catch (CancelledException e) {{
                return false;
            }} catch (ParseException e) {{
                log.appendMsg("Failed parsing solana syscall signature. See exception");
                log.appendException(e);
                break;
            }}
            model.apply();				
            func.setComment("""
                {self.description}
            """);
            break;
        '''
        return s
    
    def __str__(self) -> str:
        s = f"""
description: {self.description}
return_type: {self.return_type}
name:        {self.name}
args:        {self.args}
        """
        return s.strip()


def main():
    with open('solana_syscalls.txt', 'r') as f:
        data = f.read()
    
    functions: list[FunctionEntry] = []

    comment_lines = []
    for line_num, line in enumerate(data.splitlines()):
        line = line.strip()
        if not line:
            continue

        # skip comments
        if line.startswith("#"):
            continue

        # we have a description
        if line.startswith("///"):
            comment_lines.append(line[3:].strip())
            continue
        
        # not empty, no description, must be a function declaration
        func = FunctionEntry(line, '\n'.join(comment_lines), line_num)
        comment_lines = []
        functions.append(func)
    
    for func in functions:
        try:
            func.parse()
        except KeyboardInterrupt:
            raise
        # print(func)
    
    java_code = []
    for func in functions:
        try:
            code = func.generate_java_code()
            java_code.append(code)
        except KeyboardInterrupt:
            raise
    
    print("// vvv CODE IS AUTOGENERATED BY syscalls_codegen.py")
    print('\n'.join(java_code))
    print("// ^^^ CODE IS AUTOGENERATED BY syscalls_codegen.py")


if __name__ == '__main__':
    main()